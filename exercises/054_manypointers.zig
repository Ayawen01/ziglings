//
// 你也可以在不使用切片的情况下，创建指向多个项的指针。
//
//     var foo: [4]u8 = [4]u8{ 1, 2, 3, 4 };
//     var foo_slice: []u8 = foo[0..];
//     var foo_ptr: [*]u8 = &foo;
//
// foo_slice和foo_ptr之间的区别是，切片有一个已知的长度。指针没有。你必须自己跟踪foo_ptr指向
// 的u8s的数量！
//
const std = @import("std");

pub fn main() void {
    // 仔细看一下我们强制转换zen12字符串的数组类型（字符串的真实本质将在我们学习了一些额外
    // 的特性后揭示）：
    const zen12: *const [21]u8 = "Memory is a resource.";
    //
    //   强制转换为切片也是有效的：
    //         const zen12: []const u8 = "...";
    //
    // 现在让我们把它变成一个“多项指针”：
    const zen_manyptr: [*]const u8 = zen12;

    // 只要你自己跟踪长度，就可以像数组或切片一样访问zen_manyptr！
    //
    // Zig中的“字符串”是一个指向const u8值数组（或者如上所示，const u8值切片）的指针。所以，
    // 我们可以把一个const u8的“多项指针”当作一个字符串，只要我们能把它转换成一个切片。（提示：
    // 我们知道长度！）
    //
    // 请修复这一行，以便下面的print语句可以打印它：
    const zen12_string: []const u8 = zen_manyptr[0..zen12.len];

    // 这是真相的时刻！
    std.debug.print("{s}\n", .{zen12_string});
}
//
// 这些指针类型是不是开始让你感到困惑了？
//
//     免费的ZIG指针速查表！（以u8为例。）
//   +---------------+----------------------------------------------+
//   |  u8           |  一个u8                                      |
//   |  *u8          |  指向一个u8的指针                             |
//   |  [2]u8        |  两个u8                                      |
//   |  [*]u8        |  指向未知数量的u8s的指针                      |
//   |  [*]const u8  |  指向未知数量的不可变u8s的指针                 |
//   |  *[2]u8       |  指向一个包含2个u8s的数组的指针                |
//   |  *const [2]u8 |  指向一个不可变的包含2个u8s的数组的指针         |
//   |  []u8         |  u8s的切片                                    |
//   |  []const u8   |  不可变u8s的切片                              |
//   +---------------+----------------------------------------------+

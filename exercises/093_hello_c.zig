// 当Andrew Kelley在2016年2月8日的博客中宣布了一个新的编程语言——Zig——的想法时，
// 他也立即表明了他的雄心壮志：要取代C语言！
//
// 为了能够实现这个目标，Zig应该尽可能与其“前身”兼容。
// 只有在不使用复杂的包装器的情况下，才有可能在现有的C程序中交换单个模块，
// 才有成功的机会。
//
// 因此，调用C函数和反之亦然非常“顺畅”。
//
// 要在Zig中调用C函数，您只需要指定包含该函数的库即可。为此，有一个与众所周知的@import()相对应的内置函数：
//
//                           @cImport()
//
// 现在，所有必需的库都可以在常规的Zig符号中包含：
//
//                    const c = @cImport({
//                        @cInclude("stdio.h");
//                        @cInclude("...");
//                    });
//
// 现在可以通过（在此示例中）常量'c'调用函数：
//
//                    c.puts("Hello world!");
//
// 顺便说一句，大多数C函数都有整数值形式的返回值。
// 例如，puts()返回输出字符数。如果发生错误，则可以评估错误（返回<0）或获得其他信息。
//
// 为了使所有这些不再是干燥的理论，现在让我们开始并从Zig中调用一个C函数吧。

// 我们众所周知的Zig“import”
const std = @import("std");

// 这里是新的C导入
const c = @cImport({
    @cInclude("unistd.h");
});

pub fn main() void {

    // 为了输出可以由Zig Builder评估的文本，我们需要将其写入错误输出。
    // 在Zig中，我们使用“std.debug.print”，在C中，我们可以指定文件描述符，即2用于错误控制台。
    //
    // 在这个练习中，我们使用'write'输出17个字符，
    // 但仍然缺少一些东西...
    const c_res = write(2, "Hello C from Zig!", 17);

    // 让我们看看C的结果：
    std.debug.print(" - C result is {d} chars written.\n", .{c_res});
}
//
// 当编译带有C函数的程序时，必须考虑某些问题。
// 即Zig编译器知道它应该包含相应的库。为此，我们使用参数“lc”调用编译器，
// 例如“zig run -lc hello_c.zig”。
//
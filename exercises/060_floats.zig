//
// Zig支持IEEE-754浮点数，具有以下特定大小：f16，f32，f64，f80和f128。浮点字面量可以用科学计数法表示：
//
//     const a1: f32 = 1200.0;     // 1,200
//     const a2: f32 = 1.2e+3;     // 1,200
//     const b1: f32 = -500_000.0; // -500,000
//     const b2: f32 = -5.0e+5;    // -500,000
//
// 十六进制浮点数不能使用字母'e'，因为那是一个十六进制数字，所以我们用'p'代替：
//
//     const hex: f16 = 0x2A.F7p+3; // Wow, that's arcane!
//
// 请确保使用足够大的浮点类型来存储你的值（无论是有效数字还是规模）。
// 舍入可能可以也可能不行，但是太大或太小的数字会变成inf或-inf（正或负无穷大）！
//
//     const pi: f16 = 3.1415926535;   // 舍入为3.140625
//     const av: f16 = 6.02214076e+23; // Avogadro's inf(无穷大)!
//
// 浮点字面量有一个小数点。当对数字字面量进行数学运算时，
// 确保类型匹配。齐格不会在你背后进行不安全的类型强制转换：
//
//     var foo: f16 = 13.5 * 5;   // 错误！
//     var foo: f16 = 13.5 * 5.0; // 没问题，两者都是浮点数
//
// 请修复这个程序中的两个浮点问题，并将结果显示为整数。
const print = @import("std").debug.print;

pub fn main() void {
    // 太空梭在升空时（包括助推器和燃料箱）的大约重量是2200吨。
    //
    // 我们将以907.18kg对吨的换算率，将这个重量从吨转换为千克。
    var shuttle_weight: f32 = 907.18 * 2200;

    // 默认情况下，浮点值以科学计数法格式化。尝试用'{d}'和'{d:.3}'来看看十进制格式化是如何工作的。
    print("Shuttle liftoff weight: {d:.0}kg\n", .{shuttle_weight});
}

// 进一步了解浮点数：
//
// 作为一个例子，齐格的f16是一个IEEE 754“半精度”二进制浮点格式（“binary16”），它在内存中的存储方式如下：
//
//         0 1 0 0 0 0 1 0 0 1 0 0 1 0 0 0
//         | |-------| |-----------------|
//         |  指数         尾数
//         |
//          符号
//
// 这个例子是十进制数3.140625，它恰好是我们用f16可以表示的最接近圆周率的值，因为IEEE-754浮点数存储数字的方式：
//
//   * 符号位0使数字为正。
//   * 指数位10000是16的规模。
//   * 尾数位1001001000是十进制值584。
//
// IEEE-754通过修改这些值来节省空间：01111总是从指数位中减去（在我们的例子中，10000 - 01111 = 1，所以我们的指数是2^1），而我们的尾数位变成隐含的1之后的十进制值（所以1.1001001000或者十进制的1.5703125）！这给了我们：
//
//     2^1 * 1.5703125 = 3.140625
//
// 随意忘记这些实现细节。重要的是要知道浮点数非常擅长存储大和小的值（f64让你可以处理与宇宙中原子数量相当的规模的数字），但是数字可能会被舍入，导致结果比整数不那么精确。
//
// 趣闻：有时你会看到尾数被标记为“尾数”，但是Donald E. Knuth说不要这样做。
//
// C兼容性事实：zig还有一种专门用于与C ABI工作的浮点类型，叫做c_longdouble。
